package com.lprevidente.edb2docker.service;

import com.lprevidente.edb2docker.entity.pojo.ExploitDB;
import com.lprevidente.edb2docker.utility.Utils;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import org.jsoup.HttpStatusException;
import org.jsoup.Jsoup;
import org.jsoup.select.Elements;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.text.ParseException;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;

@Slf4j
@Service
public class ExploitDBService {

  @Value("${spring.config.exploit-db.base-url}")
  private String BASE_PATH;

  private static final Pattern PATTERN_SOFTWARE_LINK =
      Pattern.compile("Software Link(?:.*)(?::\\s)(.*)", Pattern.CASE_INSENSITIVE);

  private static final Pattern PATTERN_PRODUCT_LINK =
      Pattern.compile("Homepage(?:.*)(?::\\s)(.*)", Pattern.CASE_INSENSITIVE);

  private static final Pattern PATTERN_VERSION =
      Pattern.compile("# Version(?:.*)(?::\\s)(.*)", Pattern.CASE_INSENSITIVE);

  /**
   * Download from exploitdb the vulnerable app in the destination folder provided.
   *
   * @param filenameVulnApp the name of vulnerable app
   * @param dest the destination folder in which the vulnerable app need to be saved
   * @throws IOException throw when there is a problem performing the request or saving the file.
   */
  public void downloadVulnApp(@NonNull String filenameVulnApp, @NonNull File dest)
      throws IOException {
    Utils.copyURLToFile(BASE_PATH + "apps/" + filenameVulnApp, dest);
  }

  /**
   * Return {@link ExploitDB} with all information about the exploit.
   *
   * @param edbID the exploit-db id for the exploit
   * @return <b>null</b> if the exploit doesn't exist or and <i>empty</i> object in case doesn't
   *     exist <b>anymore</b>
   * @throws IOException throw when there is a problem performing the request or the *
   *     deserialization.
   */
  public ExploitDB getExploitDBFromSite(@NonNull Long edbID) throws IOException, ParseException {
    log.info("Request to ExploitDB - edbID = {}", edbID);
    ExploitDB exploit = null;
    // HTML page
    try {
      var doc =
          Jsoup.parse(
              new URL(BASE_PATH + "exploits/" + edbID), (int) TimeUnit.SECONDS.toMillis(120));

      Elements cardsStats = doc.getElementsByClass("card-stats");

      if (cardsStats.size()
          != 3) { // Could be happen when the exploit doesn't exist anymore and there is a
        // redirection
        log.warn("Found less/more stats thank six -> {} ", cardsStats.size());
        return exploit;
      }

      exploit = new ExploitDB();
      final var title = doc.getElementsByClass("card-title text-secondary text-center");
      exploit.setTitle(title.text());

      var card = cardsStats.get(0); // EDB-ID CVE and Verified

      var stats = card.getElementsByClass("stats-title");
      exploit.setId(stats.get(0).text());

      card = cardsStats.get(1); // Author and Type
      stats = card.getElementsByClass("stats-title");
      exploit.setAuthor(stats.get(0).text());
      exploit.setType(stats.get(1).text().toUpperCase());

      card = cardsStats.get(2); // Platform Date and Vulnerable App
      stats = card.getElementsByClass("stats-title");
      exploit.setPlatform(stats.get(0).text());
      exploit.setPublished(Utils.fromStringToDate(stats.get(1).text()));

      var select = card.getElementsByClass("card-footer").select("a[href]");
      if (select.size() > 0) {
        var href = select.attr("href");
        href = href.substring(href.lastIndexOf("/") + 1);
        exploit.setFilenameVulnApp(href);
      }

      final var code = doc.getElementsByTag("code").first();
      if (code != null) {
        final var text = code.text();

        final var softwareLinkMatcher = PATTERN_SOFTWARE_LINK.matcher(text);
        if (softwareLinkMatcher.find())
          exploit.setSoftwareLink(softwareLinkMatcher.group(1).trim());

        final var productLinkMatcher = PATTERN_PRODUCT_LINK.matcher(text);
        if (productLinkMatcher.find()) exploit.setProductLink(productLinkMatcher.group(1).trim());

        final var versionMatcher = PATTERN_VERSION.matcher(text);
        if (versionMatcher.find()) exploit.setVersion(versionMatcher.group(1).trim());
      }
    } catch (HttpStatusException ignored) {
    }
    return exploit;
  }
}
