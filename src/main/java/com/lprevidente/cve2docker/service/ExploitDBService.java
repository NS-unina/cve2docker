package com.lprevidente.cve2docker.service;

import com.lprevidente.cve2docker.api.ExploitDBAPI;
import com.lprevidente.cve2docker.entity.pojo.ExploitDB;
import com.lprevidente.cve2docker.utility.Utils;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import okhttp3.ResponseBody;
import org.apache.commons.io.FileUtils;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.select.Elements;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import retrofit2.Response;
import retrofit2.Retrofit;
import retrofit2.converter.jackson.JacksonConverterFactory;

import javax.annotation.PostConstruct;
import java.io.File;
import java.io.IOException;
import java.text.ParseException;
import java.util.regex.Pattern;

@Slf4j
@Service
public class ExploitDBService {

  @Value("${spring.config.exploit-db.base-url}")
  private String BASE_PATH;

  private ExploitDBAPI exploitDBAPI;

  private static final Pattern PATTERN_SOFTWARE_LINK =
      Pattern.compile("Software Link(?:.*)(?::\\s)(.*)", Pattern.CASE_INSENSITIVE);

  private static final Pattern PATTERN_PRODUCT_LINK =
      Pattern.compile("Homepage(?:.*)(?::\\s)(.*)", Pattern.CASE_INSENSITIVE);

  @PostConstruct
  public void initRetrofit() {
    Retrofit retrofit =
        new Retrofit.Builder()
            .baseUrl(BASE_PATH)
            .addConverterFactory(JacksonConverterFactory.create())
            .build();
    exploitDBAPI = retrofit.create(ExploitDBAPI.class);
  }

  /**
   * Download from exploitdb the vulnerable app in the destination folder provided.
   *
   * @param filenameVulnApp the name of vulnerable app
   * @param dest the destination folder in which the vulnerable app need to be saved
   * @throws IOException throw when there is a problem performing the request or saving the file.
   */
  public void downloadVulnApp(@NonNull String filenameVulnApp, @NonNull File dest)
      throws IOException {
    FileUtils.copyURLToFile(
        exploitDBAPI.downloadVulnApp(filenameVulnApp).request().url().url(), dest);
  }

  /**
   * Return {@link ExploitDB} with all information about the exploit.
   *
   * @param edbID the exploit-db id for the exploit
   * @return <b>null</b> if the exploit doesn't exist or and <i>empty</i> object in case doesn't
   *     exist <b>anymore</b>
   * @throws IOException throw when there is a problem performing the request or the *
   *     deserialization.
   */
  public ExploitDB getExploitDBFromSite(@NonNull Long edbID) throws IOException, ParseException {
    log.debug("[getExploitDB] Request to ExploitDB - Params: edbID = {}", edbID);
    Response<ResponseBody> response = exploitDBAPI.getExploit(edbID).execute();
    log.debug("[getExploitDB] Response from ExploitDB {} ", response.code());

    if (!response.isSuccessful() || response.body() == null) return null;

    // HTML page
    Document doc = Jsoup.parse(response.body().string());
    ExploitDB exploit = new ExploitDB();

    Elements cardsStats = doc.getElementsByClass("card-stats");

    if (cardsStats.size()
        != 3) { // Could be happen when the exploit doesn't exist anymore and there is a redirection
      log.warn("Found less/more stats thank six -> {} ", cardsStats.size());
      return exploit;
    }

    final var title = doc.getElementsByClass("card-title text-secondary text-center");
    exploit.setTitle(title.text());

    var card = cardsStats.get(0); // EDB-ID CVE and Verified

    var stats = card.getElementsByClass("stats-title");
    exploit.setId(stats.get(0).text());

    card = cardsStats.get(1); // Author and Type
    stats = card.getElementsByClass("stats-title");
    exploit.setAuthor(stats.get(0).text());
    exploit.setType(stats.get(1).text().toUpperCase());

    card = cardsStats.get(2); // Platform Date and Vulnerable App
    stats = card.getElementsByClass("stats-title");
    exploit.setPlatform(stats.get(0).text());
    exploit.setPublished(Utils.fromStringToDate(stats.get(1).text()));

    var select = card.getElementsByClass("card-footer").select("a[href]");
    if (select.size() > 0) {
      var href = select.attr("href");
      href = href.substring(href.lastIndexOf("/") + 1);
      exploit.setFilenameVulnApp(href);
    }

    final var code = doc.getElementsByTag("code").first();
    if (code != null) {
      final var text = code.text();

      final var softwareLinkMatcher = PATTERN_SOFTWARE_LINK.matcher(text);
      if (softwareLinkMatcher.find()) exploit.setSoftwareLink(softwareLinkMatcher.group(1).trim());

      final var productLinkMatcher = PATTERN_PRODUCT_LINK.matcher(text);
      if (productLinkMatcher.find()) exploit.setProductLink(productLinkMatcher.group(1).trim());
    }
    return exploit;
  }
}
