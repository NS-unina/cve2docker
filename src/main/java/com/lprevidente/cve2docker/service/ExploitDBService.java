package com.lprevidente.cve2docker.service;

import com.lprevidente.cve2docker.api.ExploitDBAPI;
import com.lprevidente.cve2docker.entity.model.CVE;
import com.lprevidente.cve2docker.entity.model.ExploitDB;
import com.lprevidente.cve2docker.repository.ExploitDBRepository;
import com.lprevidente.cve2docker.utility.Utils;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import okhttp3.ResponseBody;
import org.apache.commons.io.FileUtils;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.select.Elements;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import retrofit2.Response;
import retrofit2.Retrofit;
import retrofit2.converter.jackson.JacksonConverterFactory;

import javax.annotation.PostConstruct;
import javax.transaction.Transactional;
import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;

@Slf4j
@Service
public class ExploitDBService {

  @Value("${spring.config.exploit-db.base-url}")
  private String BASE_PATH;

  @Value("${spring.config.exploit-db.max-retry-next}")
  private Integer MAX_RETRY_NEXT;

  @Autowired private ExploitDBRepository repository;

  @Autowired private CVEService cveService;

  private ExploitDBAPI exploitDBAPI;

  @PostConstruct
  public void initRetrofit() {
    Retrofit retrofit =
        new Retrofit.Builder()
            .baseUrl(BASE_PATH)
            .addConverterFactory(JacksonConverterFactory.create())
            .build();
    exploitDBAPI = retrofit.create(ExploitDBAPI.class);
  }

  /**
   * Update the database with all information from Exploit DB. <b>At the first time, this operation
   * can take several hours.</b>
   */
  @Transactional
  public void update() {
    long edbID = 48000L;
    final var optionalExploitDB = repository.findFirstByAndAndIdVulnAppNotNull();

    if (optionalExploitDB.isPresent()) edbID = Long.parseLong(optionalExploitDB.get().getId());

    ExploitDB exploitDB;
    int retries = 0;
    var listExploitToSave = new ArrayList<ExploitDB>();
    try {
      do {
        exploitDB = getExploitDBFromSite(edbID);
        if (exploitDB != null && exploitDB.getId() != null) {
          retries = 0;
          if (!exploitDB.getType().equalsIgnoreCase("paper")
              && !exploitDB.getType().equalsIgnoreCase("hardware"))
            listExploitToSave.add(exploitDB);
        } else retries++;
        edbID++;
      } while (retries < MAX_RETRY_NEXT);
      repository.saveAll(listExploitToSave);
    } catch (Exception e) {
      log.error("An exception occurred: {}", e.getLocalizedMessage());
      e.printStackTrace();
    }
  }

  // TODO: valutare di cambiare nome in filename -> non mi piace
  public void downloadVulnApp(@NonNull String idVulnApp, @NonNull File dest) throws IOException {
    URL url = new URL(getURLVulnApp(idVulnApp));
    FileUtils.copyURLToFile(url, dest);
  }

  /**
   * Return {@link ExploitDB} with all information about the exploit.
   *
   * @param edbID the exploit-db id for the exploit
   * @return <b>null</b> if the exploit doesn't exist or and <i>empty</i> object in case doesn't
   *     exist <b>anymore</b>
   * @throws IOException throw when there is a problem performing the request or the *
   *     deserialization.
   */
  public ExploitDB getExploitDBFromSite(@NonNull Long edbID) throws IOException, ParseException {
    log.debug("[getExploitDB] Request to ExploitDB - Params: edbID = {}", edbID);
    Response<ResponseBody> response = exploitDBAPI.getExploit(edbID).execute();
    log.debug("[getExploitDB] Response from ExploitDB {} ", response.code());

    if (!response.isSuccessful() || response.body() == null) return null;

    // HTML page
    Document doc = Jsoup.parse(response.body().string());
    ExploitDB exploit = new ExploitDB();

    Elements cardsStats = doc.getElementsByClass("card-stats");

    if (cardsStats.size()
        != 3) { // Could be happen when the exploit doesn't exist anymore and there is a redirection
      log.warn("Found less/more stats thank six -> {} ", cardsStats.size());
      return exploit;
    }

    final var title = doc.getElementsByClass("card-title text-secondary text-center");
    exploit.setTitle(title.text());

    var card = cardsStats.get(0); // EDB-ID CVE and Verified

    var stats = card.getElementsByClass("stats-title");
    exploit.setId(stats.get(0).text());

    List<CVE> cves = new ArrayList<>();
    stats
        .get(1)
        .children()
        .forEach(
            node -> {
              try {
                cves.add(cveService.getCVE(node.text()));
              } catch (Exception ignored) {
              }
            });
    exploit.setCVEs(cves);

    card = cardsStats.get(1); // Author and Type
    stats = card.getElementsByClass("stats-title");
    exploit.setAuthor(stats.get(0).text());
    exploit.setType(stats.get(1).text().toUpperCase());

    card = cardsStats.get(2); // Platform Date and Vulnerable App
    stats = card.getElementsByClass("stats-title");
    exploit.setPlatform(stats.get(0).text());
    exploit.setPublished(Utils.fromStringToDate(stats.get(1).text()));

    var select = card.getElementsByClass("card-footer").select("a[href]");
    if (select.size() > 0) {
      var href = select.attr("href");
      href = href.substring(href.lastIndexOf("/") + 1);
      exploit.setIdVulnApp(href);
    }

    return exploit;
  }

  /**
   * Return the url used to download the vulnerable application
   *
   * @param idVulnApp the id used to identifier the vulnerable app
   * @return the complete url to download the file
   */
  public String getURLVulnApp(@NonNull String idVulnApp) {
    return exploitDBAPI.downloadVulnApp(idVulnApp).request().url().url().toString();
  }

  /**
   * Return the url used to download the Proof of Concept
   *
   * @param edbID the exploit-db id for the exploit
   * @return the complete url to download the file
   */
  public String getURLExploit(@NonNull Long edbID) {
    return exploitDBAPI.downloadExploit(edbID).request().url().url().toString();
  }
}
